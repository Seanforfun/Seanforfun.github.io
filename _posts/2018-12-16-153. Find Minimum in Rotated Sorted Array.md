---
layout: post
title:  "153. Find Minimum in Rotated Sorted Array"
date:   2018-12-16 18:47
author: Botao Xiao
categories: Leetcode
description:
---
### Question
Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]).

Find the minimum element.

You may assume no duplicate exists in the array.

```
Example 1:

Input: [3,4,5,1,2]
Output: 1

Example 2:

Input: [4,5,6,7,0,1,2]
Output: 0
```


### Thinking:
* Method: 至少有一半是in order的。

```Java
class Solution {
    public int findMin(int[] nums) {
        if(nums.length == 1) return nums[0];
        int len = nums.length;
        int mid = nums[len / 2];
        if(mid > nums[0]){  // left part in order.
            for(int i = len / 2 + 1; i < len; i++){
                if(nums[i] < nums[i - 1]) return nums[i];
            }
            return nums[0];
        }else{
            for(int i = 0; i < len / 2; i++){
                if(nums[i + 1] < nums[i]) return nums[i + 1];
            }
            return nums[len / 2];
        }
    }
}
```

### 二刷
1. 首先想到的是通过二分法解决这道题，效率是log级别的。
2. 其次可以通过判断中间值和两端的大小的问题，判断出哪一半是有序的。然后在无序的那一半判断，如果出现了无序，则哪一个结点为最小值，如果另一半也有序，则最小值出现在端点。
```Java
class Solution {
    public int findMin(int[] nums) {
        if(nums.length == 1) return nums[0];
        int mid = nums.length / 2;
        if(nums[mid] > nums[0]){
            for(int i = mid + 1; i < nums.length; i++)
                if(nums[i] < nums[i - 1]) return nums[i];
            return nums[0];
        }else{
            for(int i = 1; i <= mid; i++)
                if(nums[i] < nums[i - 1]) return nums[i];
            return nums[mid];
        }
    }
}
```
